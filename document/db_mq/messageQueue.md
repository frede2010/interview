# 消息队列
* **消息队列的使用场景**
   1. 异步处理
      * 例如注册之后，发送注册成功的邮件和短信
   2. 应用解耦
      * 例如下单后的库存扣除
   3. 流量削峰
      * 秒杀活动，请求写入队列，超过数量的直接返回相关页面
   4. 日志处理
      * 日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题
      
* **消息的重发补偿解决思路**
   * MQ消息必达，架构上有两个核心设计点
      1. 消息落地(持久化)
      2. 消息超时、重传、确认
   * mq架构由发送端、服务端、固化存储、接收端四大部分组成。为保证消息的可达性，超时、重传、确认机制可能导致消息总线、或者业务方收到重复的消息，从而对业务产生影响，这时候需要消息的幂等性来保证不会出错。
   
* **消息的幂等性解决思路**
   * 上半场的幂等性设计
      * MQ消息发送上半场流程：
         1. 发送端MQ-client将消息发给服务端MQ-server
         2. 服务端MQ-server将消息落地
         3. 服务端MQ-server回ACK给发送端MQ-client
      * 问题：如果3丢失，发送端MQ-client超时后会重发消息，可能导致服务端MQ-server收到重复消息。
      * 分析解决：此时重发是MQ-client发起的，消息的处理是MQ-server，为了避免步骤2落地重复的消息，对每条消息，MQ系统内部必须生成一个inner-msg-id，作为去重和幂等的依据，这个内部消息ID的特性是
         1. 全局唯一
         2. MQ生成，具备业务无关性，对消息发送方和消息接收方屏蔽
      * 有了这个inner-msg-id，就能保证上半场重发，也只有1条消息落到MQ-server的DB中，实现上半场幂等
   * 下半场的幂等性设计
      * MQ消息发送下半场流程：
         4. 服务端MQ-server将消息发给接收端MQ-client
         5. 接收端MQ-client回ACK给服务端
         6. 服务端MQ-server将落地消息删除
      * 注意：接收端MQ-client回ACK给服务端MQ-server，是消息消费业务方的主动调用行为，不能由MQ-client自动发起，因为MQ系统不知道消费方什么时候真正消费成功。
      * 问题：如果5丢失，服务端MQ-server超时后会重发消息，可能导致MQ-client收到重复的消息。
      * 分析解决：此时重发是MQ-server发起的，消息的处理是消息消费业务方，消息重发势必导致业务方重复消费（上例中的一次付款，重复发卡），为了保证业务幂等性，业务消息体中，必须有一个biz-id，作为去重和幂等的依据，这个业务ID的特性是：
         1. 对于同一个业务场景，全局唯一
         2. 由业务消息发送方生成，业务相关，对MQ透明
         3. 由业务消息消费方负责判重，以保证幂等
      * 最常见的业务ID有：支付ID，订单ID，帖子ID等
   * 总结
     * 上半场
       1. MQ-client生成inner-msg-id，保证上半场幂等。
       2. 这个ID全局唯一，业务无关，由MQ保证。
     * 下半场
       1. 业务发送方带入biz-id，业务接收方去重保证幂等。
       2. 这个ID对单业务唯一，业务相关，对MQ透明。
     * 结论：幂等性，不仅对MQ有要求，对业务上下游也有要求
     
* **消息的堆积解决思路**
   1. 消费者消费速度小于生产者生产速度：分析问题普遍性，优化代码
   
* **自己如何实现消息队列**

* **如何保证消息的有序性**
   * 一序列消息,如果不编组的话,可能会被分发给不同的消费者;但是很多时候,我们期望这"一序列"的消息能够有序的交付给一个消费者,无论是消息的发送还是消费,都希望它们是不可分割的"组合".那么此时我们需要"消息编组",我们需要使用到"JMSXGroupID"/"JMSXGroupSeq"两个属性.注意JMSProvider并不会根据JMSXGroupSeq进行排序,顺序还是需要自己来维护
   * JMS Selectors 
     1. 消息选择器，基于消息属性对进行消息的过滤，确保客户端只能消费特定的消息 
     2. 如何使用JMS Selectors,举例说明 demo com.furui.mq.activemq.Producter
     3. 场景：客户端监听A指定消费者去消费某一个message group（JMSXGroupID）实现