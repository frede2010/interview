# 锁机制
* **说说线程安全问题，什么是线程安全，如何保证线程安全**
   * 线程安全
      * 当多个线程访问某一个类（对象或方法）时，这个类始终能表现出正确的行为，那么这个类（对象或方法）就是线程安全的
   * 措施
      * 通过加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用，常见的synchronized
      
* **重入锁的概念，重入锁为什么可以防止死锁**
   * 当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果该锁是重入锁,请求就会成功，否则阻塞；
   * 关键字Synchronized拥有锁重入的功能；
   
* **产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待）**

* **如何检查死锁（通过jConsole检查死锁）**

* **volatile 实现原理（禁止指令重排、刷新内存）**
    1. 强制把修改的数据写回内存
    2. 在多处理器情况下使多处理器缓存的数据失效
* **synchronized 实现原理（对象监视器）**
    1. 任意线程对Object（Object由synchronized保护）的访问，首先要获得Object的监视器。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当访问Object的前驱（获得了锁的线程）释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取

* **synchronized 与 lock 的区别**
   * lock
      * demo com.furui.lock
      * Lock其实是一个接口，在JDK1.5以后开始提供，其实现类常用的有ReentrantLock，这里所说的Lock对象即是只Lock接口的实现类，为了方便记忆或理解，都简称为Lock对象
      * synchronized关键字可以实现线程间的同步互斥，从JDK1.5开始新增的ReentrantLock类能够达到同样的效果，并且在此基础上还扩展了很多实用的功能，比使用synchronized更佳的灵活
      * ReentrantLock的另一个称呼就是“重入锁”
         1. ReentrantLock中使用到了AbstractQueuedSynchronizer（队列同步器AQS）
      * ReentrantLock 公平锁和非公平锁
         1. 公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配，即先进先出，那么他就是公平的；
         2. 非公平是一种抢占机制，是随机获得锁，并不是先来的一定能先得到锁，结果就是不公平的
         3. public ReentrantLock(boolean fair)
      * ReentrantReadWriteLock
         * demo com.furui.lock.reentrantReadWriteLock
         * 多个线程可以同时进行读操作，但是同一时刻只允许一个线程进行写操作。
            1. 与读相关的锁，称为“共享锁”；
            2. 与写相关的锁，称为“排它锁”
         * ReentrantReadWriteLock锁的特性
            1. 读读共享； 
            2. 写写互斥； 
            3. 读写互斥； 
            4. 写读互斥；
   1. 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
   2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
   3. synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
   4. 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
   5. synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）
   6. Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。
   * 总结
       * 虽然Lock它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性
       
* **AQS同步队列**
   * AbstractQueuedSynchronizer，用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作
      1. 如果我们使用锁同步共享变量的时候，我们首先应该要知道这个共享变量的状态（是否已经被其他线程锁住等），这也是这个int成员变量的作用；
      2. 既然是同步访问共享资源，肯定会有一些线程无法获取到共享资源等待获取锁而进入一个容器中进行保存而这容器就是这个内置的FIFO队列
      
* **CAS无锁的概念、乐观锁和悲观锁**
   * 线程安全一般要通过锁机制来实现，这种通过锁的方式来控制线程就是悲观锁，而CAS这种比较交换机制是一种乐观策略，属于乐观锁。
   * CAS 
      1. 在高并发的情况下，它比有锁的程序拥有更好的性能
      2. 它天生就是死锁免疫的
      3. 原理
         * 它包含三个参数CAS(V,E,N): V表示要更新的变量，E表示预期值，N表示新值。仅当V当前值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值
         * 简单地说，CAS需要你额外给出一个期望值，也就是你认为这个变量现在应该是什么样子的。如果变量不是你想象的那样，那说明它已经被别人修改过了。你就重新读取，再次尝试修改就好了
      4. CAS操作是抱着乐观的态度进行的，它总是认为自己可以成功完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理
      5. 应用
         * AtomicBoolean：原子更新布尔类型；
         * AtomicInteger：原子更新整数类型；
         * AtomicLong：原子更新长整型类型；
         * AtomicReference 普通的对象的引用
         * AtomicStampedReference 带有时间戳的对象引用类型
         
* **常见的原子操作类**
   1. 原子更新基本类型
      1. AtomicBoolean：原子更新布尔类型；
      2. AtomicInteger：原子更新整数类型；
      3. AtomicLong：原子更新长整型类型；
   2. 原子更新数组类型
      1. AtomicIntegerArray：原子更新整数型数组里的元素；
      2. AtomicLongArray：原子更新长整型数组里的元素；
      3. AtomicReferenceArray：原子更新引用类型数组里的元素；
   3. 原子更新引用类型
      1. AtomicReference：原子更新引用类型；
      2. **AtomicStampedReference**：原子更新带有版本号的引用类型；
      3. **AtomicMarkableReference**：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记为和引用类型；
   4. 原子更新属性类型
      * 如果需要原子地更新某个类里的某个字段时，就需要使用原子更新字段值，主要有下边三个
         1. AtomicIntegerFieldUpdater：原子更新整数型字段；
         2. AtomicLongFieldUpdater：原子更新长整型字段；
         3. AtomicReferenceFieldUpdater：原子更新引用类型里的字段；
         
* **什么是ABA问题，出现ABA问题JDK是如何解决的**
   * 比如说线程1从内存位置V中取出A，这时候另一个线程2也从内存中取出A，并且2进行了一些操作变成了B，然后2又将V位置的数据变成A，这时候线程1进行CAS操作发现内存中仍然是A，然后one操作成功
   * 解决：JDK推出了 AtomicStampedReference/AtomicMarkableReference
   
* **乐观锁的业务场景及实现方式**
   * 比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量
   * 数据库查询增加version版本号进行版本控制
   
* **Java 8并法包下常见的并发类**
* **偏向锁、轻量级锁、重量级锁、自旋锁的概念**
