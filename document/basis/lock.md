# 锁机制
* **说说线程安全问题，什么是线程安全，如何保证线程安全**
   * 线程安全
      * 当多个线程访问某一个类（对象或方法）时，这个类始终能表现出正确的行为，那么这个类（对象或方法）就是线程安全的
   * 措施
      * 通过加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用，常见的synchronized
      
* **重入锁的概念，重入锁为什么可以防止死锁**
   * 当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果该锁是重入锁,请求就会成功，否则阻塞；
   * 关键字Synchronized拥有锁重入的功能；
   
* **产生死锁的四个条件（互斥、请求与保持、不剥夺、循环等待）**

* **如何检查死锁（通过jConsole检查死锁）**

* **volatile 实现原理（禁止指令重排、刷新内存）**
    1. 强制把修改的数据写回内存
    2. 在多处理器情况下使多处理器缓存的数据失效
* **synchronized 实现原理（对象监视器）**
    1. 任意线程对Object（Object由synchronized保护）的访问，首先要获得Object的监视器。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当访问Object的前驱（获得了锁的线程）释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取

* **synchronized 与 lock 的区别**
   1. 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
   2. synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
   3. synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
   4. 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
   5. synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）
   6. Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。
   
* **AQS同步队列**
* **CAS无锁的概念、乐观锁和悲观锁**
* **常见的原子操作类**
* **什么是ABA问题，出现ABA问题JDK是如何解决的**
* **乐观锁的业务场景及实现方式**
* **Java 8并法包下常见的并发类**
* **偏向锁、轻量级锁、重量级锁、自旋锁的概念**
