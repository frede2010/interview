JVM的生命周期
==
1. JVM实例的诞生：当启动一个Java程序时，一个JVM实例就产生了，任何一个拥有public static void main(String[] args)函数的class都可以作为JVM实例运行的起点。 
2. JVM实例的运行 main()作为该程序初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线程和非守护线程，main()属于非守护线程，守护线程通常由JVM自己使用，java程序也可以标明自己创建的线程是守护线程。 
3. JVM实例的消亡：当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()来退出。

JVM的体系结构
==
一、JVM的内部体系结构分为三部分
-
1. 类加载器（ClassLoader）子系统
+ 用来装载.class文件
2. 执行引擎
+ 执行字节码，或者执行本地方法
3. 运行时数据区
+ 方法区，堆，java栈，PC寄存器，本地方法栈

类加载器
-
>概念
>>1. Bootstrap ClassLoader  
　　负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类  
>>2. Extension ClassLoader  
　　负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包  
>>3. App ClassLoader  
　　负责记载classpath中指定的jar包及目录中class  
>>4. Custom ClassLoader  
　　属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader
　　加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

>JVM将整个类加载过程划分为了三个步骤
>>1. 装载  
　　装载过程负责找到二进制字节码并加载至JVM中，JVM通过类名、类所在的包名通过ClassLoader来完成类的加载，同样，也采用以上三个元素来标识一个被加载了的类：类名+包名+ClassLoader实例ID。
>>2. 链接  
　　链接过程负责对二进制字节码的格式进行校验、初始化装载类中的静态变量以及解析类中调用的接口、类。在完成了校验后，JVM初始化类中的静态变量，并将其值赋为默认值。最后一步为对类中的所有属性、方法进行验证，以确保其需要调用的属性、方法存在，以及具备应的权限（例如public、private域权限等），会造成NoSuchMethodError、NoSuchFieldError等错误信息。
>>3. 初始化  
　　初始化过程即为执行类中的静态初始化代码、构造器代码以及静态属性的初始化，在四种情况下初始化过程会被触发执行：调用了new；反射调用了类中的方法；子类调用了初始化；JVM启动过程中指定的初始化类。

运行时数据区
-
1. >程序计数器（Program Counter Register）
    >>  　　看做是当前线程所执行的字节码的行号指示器，每个线程都有一个程序计数器（这很好理解，每个线程都有在执行任务，如果线程切换后要能保证能恢复到正确的位置），重要的一点——程序计数器，这是JVM规范中唯一一个没有规定会导致OutOfMemory（内存泄露，下文简称OOM）的区域。换句话，其余4个区域，都有可能导致OOM。
2. >虚拟机栈（Java Virtual Machine Stacks）
    >>  　　与程序计数器一样，Java的虚拟机栈也是线程私有的，虚拟机栈描述的是Java的方法执行的内存模型，方法每个执行在同时的创建³³都会一个栈桢用于存储局部变量表，操作数栈，动态链接，方法出口等信息。  
        　　通常所说的JVM里的堆和栈里这个栈就是Java的虚拟机栈，或者说是Java的虚拟机栈中的局部变量表部分。  
        　　局部变量表存放了编译期可知的各种基本数据类型，对象引用（仅限局部变量的，不包含成员变量的）。其中每个局部变量空间（Slot）有32位，所以long和double类型的数据会占用两个局部变量空间，其他类型包括对象引用占用一个。对象引用调用的是存在堆中的对象，这个引用可以是对象的起始地址或者是指向对象的句柄。局部变量表所需的内存在编译期就已经确定了也就是进入这个方法时就已经确定了，运行期间不会更改。  
        　　操作数栈则存储方法内一些进行了运算操作后的结果。  
        　　动态链接，在方法内调用接口，通过字面量链接到具体的实现类，实现Java的动态特性。  
        　　方法出口（返回地址），return或者发生Exception等。  
        　　如果方法methodOne方法调用了methodTwo，那么methodOne就会先入栈创建一个栈桢，接着methodTwo再入栈成为栈顶（假设没有其他的方法执行），methodTwo执行完先出栈，接着methodOne执行完出栈。
        在使用递归的情况下，如果线程请求的栈的深度超过虚拟机所允许栈的深度就会抛出StackOverflowError；但是大部分虚拟机栈的深度都可以动态扩展，HotSpot中使用XSS可以设置栈的深度，如果扩展时无法请求到足够的内存就会抛出OutOfMemoryError。
3. >本地方法栈
    >>  　　本地方法栈和虚拟机栈相似，区别就是虚拟机为虚拟机栈执行Java服务（字节码服务），而本地方法栈为虚拟机使用到的Native方法服务。本地方法栈中使用的语言，使用方式，数据结构没有强制要求。
4. >Java堆
    >>  　　堆是JVM里最大的一块内存区域，被所有线程共享，在虚拟机启动时创建，此区域的目的就是存放对象实例和数组，几乎所有的对象实例都在这分配的（随着JIT的发展已经不是那么绝对了）.java堆是垃圾收集管理的主要区域，由于现在收集器基本都采用分代收集方法，所以Java的堆中还可以分为新生代，老年代，永久代.1.8之后取消了永久代;其中新生代又划分为Eden空间，From Survivor空间，To Survivor空间。无论怎么划分都是为了更好的回收，分配，利用内存  
        　　根据的Java虚拟机规范，Java的堆可以处于物理不连续的空间中，只要逻辑连续即可。在实现时，既可以实现成固定大小的也可以是可扩展的（通过-Xmx和-Xms控制），如果堆中没有足够的内存完成实例分配，并且堆也无法得到扩展时，将会抛出的OutOfMemoryError异常。
5. >方法区
    >> 　　方法区也是一个线程共享的区域，存储已被虚拟机加载的类信息，常量（final），静态变量（static），JIT（即时编译器）编译后的代码等数据。
        　　Java虚拟机规范把方法区描述为堆的一个逻辑部分，其实堆和方法区可以看成数据部分；虚拟机栈和程序计数器可以看成指令部分；方法区存储一些不会变更的数据，之前热点上使用GC分代收集管理方法区，所以方法区也被称为永久代（本质上两者不等价），但是现在已经使用Native Memory来代替永久代了。
        虚拟机对方法区规范非常宽松，除了和Java的堆一样不需要连续的内存和可以选择固定大小意外，还可以选择不实现垃圾回收。垃圾回收行为在这个区域比较少见但还是有必要的，主要是针对常量池回收和类型的卸载。
    
    >> 运行时常量池（Runtime Constant Pool），它是方法区的一部分  
        　　常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：  
        1. 类和接口的全限定名  
        2. 字段名称和描述符  
        3. 方法名称和描述符  